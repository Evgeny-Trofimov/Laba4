#include <iostream>
#include <iomanip>
#include <cmath>

using namespace std;

// Функция уравнения: f(x) = sin(x) - 2x - 1
double f(double x) {
    return sin(x) - 2 * x - 1;
}

// Производная функции: f'(x) = cos(x) - 2
double df(double x) {
    return cos(x) - 2;
}

// Метод половинного деления для нахождения корня уравнения
// Принимает:
// a - левая граница интервала
// b - правая граница интервала
// eps - требуемая точность
void bisection_method(double a, double b, double eps) {
    // Вывод заголовка таблицы
    cout << "\nМетод половинного деления:\n";
    cout << "-------------------------------------------------\n";
    cout << "| N |     a_n     |     b_n     |   b_n - a_n   |\n";
    cout << "-------------------------------------------------\n";
    
    int n = 0;          // Счетчик итераций
    double c;           // Середина текущего интервала
    
    // Основной цикл метода: продолжается пока длина интервала больше eps
    while (fabs(b - a) > eps) {
        c = (a + b) / 2;  // Находим середину интервала
        // Выводим текущее состояние
        cout << "|" << setw(3) << (n+1) << "|" << setw(12) << a << "|" << setw(12) << b << "|" << setw(15) << (b - a) << "|\n";
        
        // Проверяем, является ли середина интервала корнем
        if (f(c) == 0.0) {
            break;
        } 
        // Определяем, в какой половине находится корень
        else if (f(c) * f(a) < 0) {
            b = c;  // Корень в левой половине
        } else {
            a = c;  // Корень в правой половине
        }
        n++;  // Увеличиваем счетчик итераций
    }
    
    // Вывод результатов
    cout << "-------------------------------------------------\n";
    cout << "Корень: " << (a + b) / 2 << endl;
    cout << "Количество итераций: " << n << endl;
}

// Метод Ньютона для нахождения корня уравнения
// Принимает:
// x0 - начальное приближение
// eps - требуемая точность
void newton_method(double x0, double eps) {
    // Вывод заголовка таблицы
    cout << "\nМетод Ньютона:\n";
    cout << "-------------------------------------------------\n";
    cout << "| N |     X_n     |    X_{n+1}   | X_{n+1} - X_n |\n";
    cout << "-------------------------------------------------\n";
    
    int n = 0;              // Счетчик итераций
    double x1 = x0 - f(x0) / df(x0);  // Первое приближение
    
    // Основной цикл метода: продолжается пока разность приближений больше eps
    while (fabs(x1 - x0) > eps) {
        // Выводим текущее состояние
        cout << "|" << setw(3) << (n+1) << "|" << setw(12) << x0 << "|" << setw(12) << x1 << "|" << setw(15) << (x1 - x0) << "|\n";
        
        x0 = x1;  // Переходим к следующему приближению
        x1 = x0 - f(x0) / df(x0);  // Вычисляем новое приближение по формуле Ньютона
        n++;      // Увеличиваем счетчик итераций
    }
    
    // Вывод результатов
    cout << "-------------------------------------------------\n";
    cout << "Корень: " << x1 << endl;
    cout << "Количество итераций: " << n << endl;
}

// Метод простых итераций для нахождения корня уравнения
// Принимает:
// x0 - начальное приближение
// eps - требуемая точность
void simple_iteration_method(double x0, double eps) {
    // Вывод заголовка таблицы
    cout << "\nМетод простых итераций:\n";
    cout << "-------------------------------------------------\n";
    cout << "| N |     X_n     |    X_{n+1}   | X_{n+1} - X_n |\n";
    cout << "-------------------------------------------------\n";
    
    // Преобразование уравнения к виду x = phi(x)
    auto phi = [](double x) { return (sin(x) - 1) / 2; };
    
    int n = 0;              // Счетчик итераций
    double x1 = phi(x0);    // Первое приближение
    
    // Основной цикл метода: продолжается пока разность приближений больше eps
    while (fabs(x1 - x0) > eps) {
        // Выводим текущее состояние
        cout << "|" << setw(3) << (n+1) << "|" << setw(12) << x0 << "|" << setw(12) << x1 << "|" << setw(15) << (x1 - x0) << "|\n";
        
        x0 = x1;        // Переходим к следующему приближению
        x1 = phi(x0);   // Вычисляем новое приближение
        n++;            // Увеличиваем счетчик итераций
    }
    
    // Вывод результатов
    cout << "-------------------------------------------------\n";
    cout << "Корень: " << x1 << endl;
    cout << "Количество итераций: " << n << endl;
}

int main() {
    const double eps = 1e-4;       // Точность вычислений
    double a = -1.0, b = 0.0;      // Интервал, где находится корень
    double x0 = -0.5;              // Начальное приближение
    
    // Вызываем метод половинного деления
    bisection_method(a, b, eps);
    
    // Вызываем метод Ньютона
    newton_method(x0, eps);
    
    // Вызываем метод простых итераций
    simple_iteration_method(x0, eps);
    
    return 0;
}
