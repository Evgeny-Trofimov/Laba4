require 'bigdecimal'
require 'bigdecimal/util'
require 'bigdecimal/math'

include BigMath

# Определяем функцию f(x) = sin(x) - 2x - 1, корни которой будем искать
def f(x)
  Math.sin(x) - 2 * x - 1
end

# Определяем производную функции f'(x) = cos(x) - 2 (нужна для метода Ньютона)
def df(x)
  Math.cos(x) - 2
end

# Реализация метода половинного деления (бисекции)
def bisection_method(a, b, eps)
  puts "\nМетод половинного деления:"
  puts "-------------------------------------------------"
  puts "| N |     a_n     |     b_n     |   b_n - a_n   |"
  puts "-------------------------------------------------"
  
  n = 0       # Счетчик итераций
  c = 0.0     # Середина интервала
  
  # Основной цикл метода - работает пока длина интервала больше заданной точности
  while (b - a).abs > eps
    c = (a + b) / 2.0  # Находим середину текущего интервала
    
    # Выводим текущее состояние в табличном формате
    printf("|%3d|%12.6f|%12.6f|%15.6f|\n", n+1, a, b, b - a)
    
    # Проверяем условия для выбора нового интервала
    if f(c) == 0.0
      break  # Нашли точный корень
    elsif f(c) * f(a) < 0
      b = c  # Корень в левой половине
    else
      a = c  # Корень в правой половине
    end
    n += 1  # Увеличиваем счетчик итераций
  end
  
  # Выводим результаты работы метода
  puts "-------------------------------------------------"
  puts "Корень: #{(a + b) / 2.0}"  # Среднее значение как приближение корня
  puts "Количество итераций: #{n}"  # Число потребовавшихся итераций
end

# Реализация метода Ньютона (метода касательных)
def newton_method(x0, eps)
  puts "\nМетод Ньютона:"
  puts "-------------------------------------------------"
  puts "| N |     X_n     |    X_{n+1}   | X_{n+1} - X_n |"
  puts "-------------------------------------------------"
  
  n = 0  # Счетчик итераций
  x1 = x0 - f(x0) / df(x0)  # Первое приближение по формуле Ньютона
  
  # Итерационный процесс - пока разница между приближениями больше точности
  while (x1 - x0).abs > eps
    # Выводим текущую итерацию
    printf("|%3d|%12.6f|%12.6f|%15.6f|\n", n+1, x0, x1, x1 - x0)
    
    # Обновляем значения для следующей итерации
    x0 = x1
    x1 = x0 - f(x0) / df(x0)  # Следующее приближение по формуле Ньютона
    n += 1  # Увеличиваем счетчик итераций
  end
  
  # Выводим результаты
  puts "-------------------------------------------------"
  puts "Корень: #{x1}"
  puts "Количество итераций: #{n}"
end

# Реализация метода простых итераций
def simple_iteration_method(x0, eps)
  puts "\nМетод простых итераций:"
  puts "-------------------------------------------------"
  puts "| N |     X_n     |    X_{n+1}   | X_{n+1} - X_n |"
  puts "-------------------------------------------------"
  
  # Преобразуем уравнение к виду x = φ(x), где φ(x) = (sin(x) - 1)/2
  phi = ->(x) { (Math.sin(x) - 1) / 2.0 }
  
  n = 0  # Счетчик итераций
  x1 = phi.call(x0)  # Первое приближение
  
  # Итерационный процесс
  while (x1 - x0).abs > eps
    # Выводим текущую итерацию
    printf("|%3d|%12.6f|%12.6f|%15.6f|\n", n+1, x0, x1, x1 - x0)
    
    # Обновляем значения для следующей итерации
    x0 = x1
    x1 = phi.call(x0)
    n += 1
  end
  
  # Выводим результаты
  puts "-------------------------------------------------"
  puts "Корень: #{x1}"
  puts "Количество итераций: #{n}"
end

# Основная программа
eps = 1e-4      # Задаваемая точность вычислений
a = -1.0        # Левая граница начального интервала
b = 0.0         # Правая граница начального интервала
x0 = -0.5       # Начальное приближение для итерационных методов

# Вызываем все три метода для сравнения
bisection_method(a, b, eps)          # Метод половинного деления
newton_method(x0, eps)               # Метод Ньютона
simple_iteration_method(x0, eps)     # Метод простых итераций
